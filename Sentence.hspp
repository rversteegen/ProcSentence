# Ported from GAD'42


# Changes:
# -instead of a HIDE_NUM class, HIDE_NUM and SHOW_NUM are special args that must
#  process a number in form_msg string
# -string members renamed to follow name! convention

# Because other classes can't inherit from Noun, instead
# an object has a nounbase ptr, and a name! member.
# When creating an object like an item or entity

# When creating a temp Noun

#######################   SENTENCES ##########################################


defineconstant(0, idx:name!)
defineconstant(1, idx:pronoun!)
#defineconstant(2, idx:unique)
#defineconstant(3, idx:always_plural)  # eg Pills
setsizeof  Noun, 2, NOUN

# setsizeof  NounWrapper, 4, SIZE4    ## FIXME (MUST BE at least 1 larger than NOUN!)
# #defineconstant(0, idx:type)  #duplicate
# # The Noun data is at ptr + 1


# A multimethod
script, Thing_get_noun, thing, begin
    if (thing >= heap NOUN base && thing < heap NOUN end) then (
        # Hack -- can't use .type memebr since Noun is inherited
        return(loadstring(thing.name!))
    ) else if (thing.type == type:Entity) then (
        return(entity_get_noun(thing))
#    ) else if (thing.type == type:Item) then (
#        return(item_get_name(thing))
    ) else (
        scripterror(stringsprintf(98, $99="Unknown data type %d (ptr %d)", thing.type, thing))
    )
end

# A multimethod
script, Thing_get_pronoun, thing, begin
    if (thing >= heap NOUN base && thing < heap NOUN end) then (
        # Hack -- can't use .type memebr since Noun is inherited
        return(loadstring(thing.pronoun!))
    ) else if (thing.type == type:Entity) then (
        return(entity_get_pronoun(thing))
    ) else (
        scripterror(stringsprintf(98, $99="Unknown data type %d (ptr %d)", thing.type, thing))
    )
end


script, freeNoun, noun, begin
    freestring(noun.name!)
    freestring(noun.pronoun!)
    noun.name! := -99999
    noun.pronoun! := -99999
    dealloc:Noun(noun)
end


# Returns a new string
script, capitalise, str, begin
    var(ret, letter)
    ret := NS
    letter := asciifromstring(str, 1)
    if (letter >= 97 && letter <= 122) then (letter -= 32)
    ret $= str
    replacechar(ret, 1, letter)
    freestring(str)
    return(ret)
end

# Convert string to number
script, tostring, num, begin
    var(ret)
    ret := NS
    appendnumber(ret, num)
    return(ret)
end


#defineconstant(-100, HIDE_NUM)
#defineconstant(-101, SHOW_NUM)
defineconstant(-789000000, PRONOUN)   # use pronoun rather than name

# Possible todo: "a" and "an"

# Arguments can be: string IDs (0-99), or pointers to something (but NOT slicestrings)
# that can be passed to Thing_get_pronoun/noun
script, form_msg, parts_list, begin

    subscript, appendstr, str, begin
        #trace($0="segment is")
        #trace(str)

        if (stringlength(ret) > 0) then ($ret + " ")
        ret $+ str
        freestring(str)
    end

    var(i, ret, item, need_capitalise, segment, wantpronoun)
    need_capitalise := true
    wantpronoun := false
    ret := NS

    for (i, 0, parts_list.len -- 1) do (
        item := parts_list[i]
        # Can't have 
        if (item == PRONOUN) then (
            wantpronoun := true
            continue
        ) else if (item < 100) then (
            # String ID
            segment := item
            # The string gets freed by appendstr
        ) else (
            if (wantpronoun) then (
                segment := Thing_get_pronoun(item)
            ) else (
                segment := Thing_get_noun(item)
            )
        )
        if (need_capitalise) then (segment := capitalise(segment))
        need_capitalise := false
        appendstr(segment)
        wantpronoun := false

        # If string ends in '.'
        if (asciifromstring(ret, stringlength(ret)) == 46) then (need_capitalise := true)
    )
    freelist(parts_list)
    return (ret)
end




script, test_form_msg, begin

    var(slicestrings, nstrings, wasstack)
    slicestrings := childcount(slicestring_parent)
    nstrings := numusedstrings
    wasstack := stack

    subscript, form_msg_lst, arg1=NIL, arg2=NIL, arg3=NIL, arg4=NIL, arg5=NIL, arg6=NIL, arg7=NIL, begin
      return(form_msg(lst8(arg1, arg2, arg3, arg4, arg5, arg6, arg7)))
    end

    subscript, test_form_msg_equal, str1, str2, begin
        if (stringcompare(str1, str2) == false) then (
            trace($1="Error! Got '"), trace(str1), trace($1="', expected '"), trace(str2), trace($1="'")
        )
    end


    var(oneself, Joules, weapon, entity, ret, item)
    oneself := alloc:Noun
    oneself.name! := savestring($"you")
    oneself.pronoun! := savestring($"you")
    #oneself.unique := True
    #oneself.firstperson := True

    Joules := alloc:Noun
    Joules.name! := savestring($"Joules")
    Joules.pronoun! := savestring($"he")
    #Joules.unique := True

    weapon := alloc:Noun
    weapon.name! := savestring($"rifle")
    weapon.pronoun! := savestring($"it")

    entity := alloc:Noun
    entity.name! := savestring($"three-armed ape")
    entity.pronoun! := savestring($"it")


    ret := form_msg_lst($"You drop your", weapon)
    $0="You drop your rifle"
    test_form_msg_equal(ret, 0)
    freestring(ret)


    ret := form_msg_lst($"You shoot the", entity, $"with a bolt of energy.", PRONOUN, entity, $"is stunned.")
    $0="You shoot the three-armed ape with a bolt of energy. It is stunned."
    test_form_msg_equal(ret, 0)
    freestring(ret)

    ret := form_msg_lst($"the", entity, $"is shot through by a", $"bolt of energy.", PRONOUN, entity, $"is mortally wounded!")
    $0="The three-armed ape is shot through by a bolt of energy. It is mortally wounded!"
    test_form_msg_equal(ret, 0)
    freestring(ret)

    ret := form_msg_lst(Joules, $"explodes as", PRONOUN, Joules, $"enters the chamber!")
    $0="Joules explodes as he enters the chamber!"
    test_form_msg_equal(ret, 0)
    freestring(ret)

    item := alloc:Noun
    item.name! := savestring($"eight-sided coin")
    item.pronoun! := savestring($"it")


    ret := form_msg_lst($"a", item)
    $0="A eight-sided coin"   #### fixme
    test_form_msg_equal(ret, 0)
    freestring(ret)

    ret := form_msg_lst($"the", item)
    $0="The eight-sided coin"
    test_form_msg_equal(ret, 0)
    freestring(ret)

    freeNoun(oneself)
    freeNoun(Joules)
    freeNoun(weapon)
    freeNoun(item)
    freeNoun(entity)


    listusedstrings()
    assert(nstrings == numusedstrings)
    assert(childcount(slicestring_parent) == slicestrings)
    assert(wasstack == stack)

    trace($0="form_msg tests done.")
end